import { Component, OnInit, AfterViewInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { PacienteService } from '../../services/paciente.service';
import { EvaluacionService, EvaluacionSensorial } from '../../services/evaluacion.service';

@Component({
  selector: 'app-pagina2',
  templateUrl: './pagina2.component.html',
  styleUrls: ['./pagina2.component.css']
})
export class Pagina2Component implements OnInit, AfterViewInit {

  totalQuestions = 80;
  answeredQuestions = 0;
  progressPercentage = 0;
  circumference = 2 * Math.PI * 34; // radio = 34
  strokeDashoffset = this.circumference;
  showFloatingProgress = true;

  // Datos del paciente y evaluaci√≥n
  selectedPatient: any = null;
  patients: any[] = [];
  evaluationData: any = {};
  patientIdFromRoute: string | null = null;
  evaluacionIdFromRoute: string | null = null;
  isEditMode: boolean = false;
  currentEvaluacion: any = null;

  sectionProgress = [
    { id: 'seccion-vision', name: 'Visi√≥n', color: '#ec4899', answered: 0, total: 10, completed: false },
    { id: 'seccion-auditivo', name: 'Auditivo', color: '#667eea', answered: 0, total: 10, completed: false },
    { id: 'seccion-tactil', name: 'T√°ctil', color: '#f59e0b', answered: 0, total: 10, completed: false },
    { id: 'seccion-gusto-olfato', name: 'Gusto/Olfato', color: '#10b981', answered: 0, total: 10, completed: false },
    { id: 'seccion-conciencia-corporal', name: 'Conciencia', color: '#ef4444', answered: 0, total: 10, completed: false },
    { id: 'seccion-equilibrio-movimiento', name: 'Equilibrio', color: '#8b5cf6', answered: 0, total: 10, completed: false },
    { id: 'seccion-planificacion-ideas', name: 'Planificaci√≥n', color: '#f97316', answered: 0, total: 10, completed: false },
    { id: 'seccion-participacion-social', name: 'Participaci√≥n', color: '#06b6d4', answered: 0, total: 10, completed: false }
  ];

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private pacienteService: PacienteService,
    private evaluacionService: EvaluacionService
  ) {}

  ngOnInit() {
    this.loadPatients();
    this.checkForRouteParams();
    this.setupProgressTracking();
    this.ensureTestPatientAvailable();
  }

  ngAfterViewInit(): void {
    console.log('‚úÖ Vista inicializada - Configurando event listeners');
    this.updateProgress();
    this.setupRadioEventListeners();
    this.checkForRouteParams();
  }

  private setupRadioEventListeners(): void {
    console.log('üîß Configurando event listeners para radio buttons...');
    
    // Usar setTimeout para asegurar que el DOM est√© completamente renderizado
    setTimeout(() => {
      const radioButtons = document.querySelectorAll('input[type="radio"]');
      console.log(`üìä Configurando listeners para ${radioButtons.length} radio buttons`);
      
      radioButtons.forEach((radio: any) => {
        radio.addEventListener('change', () => {
          console.log(`üîò Radio button cambiado: ${radio.name} = ${radio.value}`);
          this.updateProgress();
        });
      });
    }, 100);
  }

  private ensureTestPatientAvailable(): void {
    console.log('üß™ Verificando disponibilidad de paciente de prueba...');
    
    // Si no hay pacientes cargados, crear uno de prueba
    if (!this.patients || this.patients.length === 0) {
      console.log('üîÑ No hay pacientes disponibles, creando paciente de prueba...');
      
      const testPatient = {
        idPaciente: '999',
        id: '999',
        nombre: 'Paciente',
        apellidoPaterno: 'DePrueba',
        apellidoMaterno: 'Test',
        rut: '12345678-9',
        telefono: '+56912345678',
        correo: 'test@test.com'
      };
      
      this.patients = [testPatient];
      this.selectedPatient = testPatient;
      
      console.log('‚úÖ Paciente de prueba creado y seleccionado:', testPatient);
    } else if (!this.selectedPatient && this.patients.length > 0) {
      // Si hay pacientes pero ninguno seleccionado, seleccionar el primero
      this.selectedPatient = this.patients[0];
      console.log('‚úÖ Paciente seleccionado autom√°ticamente:', this.selectedPatient);
    }
  }

  setupQuestionListeners() {
    console.log('üéØ Configurando listeners para radio buttons...');
    
    // Obtener todos los radio buttons del formulario
    const radioButtons = document.querySelectorAll('input[type="radio"]');
    console.log(`üìª Radio buttons encontrados: ${radioButtons.length}`);
    
    radioButtons.forEach((radio, index) => {
      radio.addEventListener('change', (event) => {
        const target = event.target as HTMLInputElement;
        console.log(`‚úÖ Respuesta seleccionada: ${target.name} = ${target.value}`);
        
        // Actualizar progreso inmediatamente
        this.updateProgress();
        
        // Log para debug
        console.log(`üìä Progreso actualizado: ${this.answeredQuestions}/${this.totalQuestions} (${this.progressPercentage}%)`);
      });
    });
    
    // Verificar estado inicial
    this.updateProgress();
  }

  scrollToSection(sectionId: string): void {
    const element = document.getElementById(sectionId);
    if (element) {
      element.scrollIntoView({ 
        behavior: 'smooth', 
        block: 'start',
        inline: 'nearest'
      });
    }
  }

  toggleFloatingProgress(): void {
    this.showFloatingProgress = !this.showFloatingProgress;
    const floatingElement = document.querySelector('.floating-progress') as HTMLElement;
    if (floatingElement) {
      floatingElement.classList.toggle('hidden');
    }
  }

  // M√©todos para manejo de pacientes
  private loadPatients(): void {
    this.pacienteService.obtenerPacientesCompletos().subscribe({
      next: (patients: any) => {
        this.patients = patients;
      },
      error: (error: any) => {
        console.error('Error cargando pacientes:', error);
        // Cargar pacientes desde localStorage como fallback
        this.loadPatientsFromStorage();
      }
    });
  }

  private loadPatientsFromStorage(): void {
    const storedPatients = localStorage.getItem('pacientes');
    if (storedPatients) {
      this.patients = JSON.parse(storedPatients);
    }
  }

  private checkForRouteParams(): void {
    this.route.queryParams.subscribe(params => {
      this.patientIdFromRoute = params['pacienteId'];
      this.evaluacionIdFromRoute = params['evaluacionId'];
      
      console.log('üìã Par√°metros de ruta:', {
        pacienteId: this.patientIdFromRoute,
        evaluacionId: this.evaluacionIdFromRoute
      });

      if (this.evaluacionIdFromRoute) {
        // Modo edici√≥n: cargar evaluaci√≥n existente
        this.isEditMode = true;
        this.loadExistingEvaluation(this.evaluacionIdFromRoute);
      } else if (this.patientIdFromRoute) {
        // Modo nuevo: solo seleccionar paciente
        this.isEditMode = false;
        this.selectPatientById(this.patientIdFromRoute);
      }
    });
  }

  private loadExistingEvaluation(evaluacionId: string): void {
    console.log('üìñ Cargando evaluaci√≥n existente:', evaluacionId);
    
    this.evaluacionService.obtenerEvaluacionPorId(parseInt(evaluacionId)).subscribe({
      next: (evaluacion) => {
        console.log('‚úÖ Evaluaci√≥n cargada:', evaluacion);
        this.currentEvaluacion = evaluacion;
        
        // Seleccionar el paciente
        this.selectPatientById(evaluacion.idPaciente.toString());
        
        // Cargar las respuestas en el formulario
        this.loadResponsesIntoForm(evaluacion.respuestas);
        
        alert(`üìñ Cargando evaluaci√≥n existente de ${evaluacion.nombreCompleto}\nProgreso: ${evaluacion.progreso}%\nEstado: ${evaluacion.estado}`);
      },
      error: (error) => {
        console.error('‚ùå Error al cargar evaluaci√≥n:', error);
        alert(`Error al cargar la evaluaci√≥n: ${error.message}`);
        // En caso de error, redirigir a nueva evaluaci√≥n
        this.isEditMode = false;
        if (this.patientIdFromRoute) {
          this.selectPatientById(this.patientIdFromRoute);
        }
      }
    });
  }

  private loadResponsesIntoForm(respuestasJson: string): void {
    try {
      console.log('üìù === INICIANDO CARGA DE RESPUESTAS ===');
      console.log('üìù Datos recibidos:', respuestasJson);
      
      let respuestas: any[];
      
      // Parsear las respuestas (pueden estar como string JSON)
      if (typeof respuestasJson === 'string') {
        respuestas = JSON.parse(respuestasJson);
      } else {
        respuestas = respuestasJson;
      }
      
      console.log('üìã Respuestas parseadas:', respuestas);
      console.log('üìä Total de respuestas a cargar:', respuestas.length);
      
      // M√∫ltiples intentos con diferentes tiempos de espera
      this.loadResponsesWithMultipleAttempts(respuestas, 0);
      
    } catch (error) {
      console.error('‚ùå Error al cargar respuestas:', error);
      alert('Error al cargar las respuestas de la evaluaci√≥n. Se iniciar√° una nueva evaluaci√≥n.');
    }
  }

  private loadResponsesWithMultipleAttempts(respuestas: any[], attemptNumber: number): void {
    const maxAttempts = 3;
    const delays = [500, 1000, 2000]; // Tiempos de espera incrementales
    
    if (attemptNumber >= maxAttempts) {
      console.log('‚ùå Se agotaron los intentos de carga');
      alert('‚ö†Ô∏è No se pudieron cargar completamente las respuestas anteriores.\nSe iniciar√° una nueva evaluaci√≥n.');
      return;
    }

    const delay = delays[attemptNumber];
    console.log(`üîÑ Intento ${attemptNumber + 1}/${maxAttempts} - Esperando ${delay}ms...`);
    
    setTimeout(() => {
      let respuestasCargadas = 0;
      let respuestasNoEncontradas = 0;
      
      console.log(`üîç === INTENTO ${attemptNumber + 1}: B√öSQUEDA DE RADIO BUTTONS ===`);
      
      // Inventario completo de radio buttons disponibles
      const todosLosRadios = document.querySelectorAll('input[type="radio"]');
      console.log(`üìä Total radio buttons disponibles: ${todosLosRadios.length}`);
      
      if (todosLosRadios.length === 0) {
        console.log('‚ö†Ô∏è No se encontraron radio buttons, reintentando...');
        this.loadResponsesWithMultipleAttempts(respuestas, attemptNumber + 1);
        return;
      }
      
      // Mostrar algunos ejemplos de radio buttons disponibles
      if (attemptNumber === 0) {
        console.log('üìã Ejemplos de radio buttons disponibles:');
        Array.from(todosLosRadios).slice(0, 8).forEach((radio: any, index) => {
          console.log(`  ${index + 1}. name="${radio.name}" value="${radio.value}" id="${radio.id}"`);
        });
      }
      
      // Intentar cargar cada respuesta
      respuestas.forEach((respuesta: any, index) => {
        if (!respuesta.name) {
          console.log(`‚ùå Respuesta ${index + 1}: Sin atributo 'name'`);
          respuestasNoEncontradas++;
          return;
        }
        
        console.log(`üîç Procesando respuesta ${index + 1}: ${respuesta.name} = ${respuesta.respuesta}`);
        
        // Estrategia 1: Buscar por name y value exactos
        let radioInput = document.querySelector(`input[name="${respuesta.name}"][value="${respuesta.respuesta}"]`) as HTMLInputElement;
        
        // Estrategia 2: Si no se encuentra, buscar por ID construido
        if (!radioInput) {
          const constructedId = `q${respuesta.name.replace('pregunta', '')}_${respuesta.respuesta}`;
          radioInput = document.getElementById(constructedId) as HTMLInputElement;
          console.log(`üîç B√∫squeda alternativa por ID: ${constructedId}`);
        }
        
        // Estrategia 3: Buscar usando querySelectorAll y filtrar
        if (!radioInput) {
          const radiosWithName = document.querySelectorAll(`input[name="${respuesta.name}"]`);
          Array.from(radiosWithName).forEach(radio => {
            if ((radio as HTMLInputElement).value === respuesta.respuesta) {
              radioInput = radio as HTMLInputElement;
              console.log(`üîç Encontrado mediante b√∫squeda filtrada`);
            }
          });
        }
        
        if (radioInput) {
          // Verificar que el elemento sea realmente un radio button
          if (radioInput.type === 'radio') {
            radioInput.checked = true;
            respuestasCargadas++;
            console.log(`‚úÖ Respuesta ${index + 1} CARGADA: ${respuesta.name} = ${respuesta.respuesta}`);
            
            // Disparar m√∫ltiples eventos para asegurar que Angular detecte el cambio
            const events = ['change', 'input', 'click'];
            events.forEach(eventType => {
              const event = new Event(eventType, { bubbles: true });
              radioInput.dispatchEvent(event);
            });
            
            // Tambi√©n intentar con eventos nativos
            if (radioInput.onchange) {
              radioInput.onchange(new Event('change') as any);
            }
          } else {
            console.log(`‚ö†Ô∏è Elemento encontrado no es un radio button: ${radioInput.type}`);
            respuestasNoEncontradas++;
          }
        } else {
          respuestasNoEncontradas++;
          console.log(`‚ö†Ô∏è Respuesta ${index + 1} NO ENCONTRADA: ${respuesta.name} = ${respuesta.respuesta}`);
          
          // Diagn√≥stico: buscar elementos similares
          const radiosWithSameName = document.querySelectorAll(`input[name="${respuesta.name}"]`);
          if (radiosWithSameName.length > 0) {
            console.log(`   üìã Radio buttons disponibles para ${respuesta.name}:`);
            radiosWithSameName.forEach((radio: any, i) => {
              console.log(`     ${i + 1}. value="${radio.value}" (buscado: "${respuesta.respuesta}")`);
            });
          } else {
            console.log(`   ‚ùå No existe ning√∫n radio button con name="${respuesta.name}"`);
          }
        }
      });
      
      console.log(`\nüìä === RESUMEN INTENTO ${attemptNumber + 1} ===`);
      console.log(`‚úÖ Respuestas cargadas: ${respuestasCargadas}`);
      console.log(`‚ùå Respuestas no encontradas: ${respuestasNoEncontradas}`);
      console.log(`üìä Total procesadas: ${respuestas.length}`);
      
      // Si cargamos al menos algunas respuestas o es el √∫ltimo intento, continuar
      if (respuestasCargadas > 0 || attemptNumber === maxAttempts - 1) {
        console.log('üîÑ Actualizando progreso...');
        this.updateProgress();
        
        // Mostrar mensaje al usuario
        const totalCargadas = respuestasCargadas;
        const totalNoEncontradas = respuestasNoEncontradas;
        
        if (totalCargadas > 0) {
          let mensaje = `‚úÖ Se cargaron ${totalCargadas} de ${respuestas.length} respuestas de la evaluaci√≥n anterior.\n\n`;
          
          if (totalNoEncontradas > 0) {
            mensaje += `‚ö†Ô∏è ${totalNoEncontradas} respuestas no se pudieron cargar.\n\n`;
          }
          
          mensaje += 'Puedes continuar completando la evaluaci√≥n.';
          alert(mensaje);
        } else {
          alert('‚ö†Ô∏è No se pudieron cargar las respuestas anteriores.\nSe iniciar√° una nueva evaluaci√≥n.');
        }
        
        console.log(`üéâ Proceso completado despu√©s de ${attemptNumber + 1} intentos`);
      } else {
        // Si no se carg√≥ nada, reintentar
        console.log(`üîÑ No se cargaron respuestas, reintentando (intento ${attemptNumber + 2})...`);
        this.loadResponsesWithMultipleAttempts(respuestas, attemptNumber + 1);
      }
      
    }, delay);
  }

  private checkForPatientId(): void {
    // Este m√©todo ya no se usa, se reemplaza por checkForRouteParams
  }

  private selectPatientById(patientId: string): void {
    const patient = this.patients.find(p => p.id === patientId);
    if (patient) {
      this.selectedPatient = patient;
    }
  }

  onPatientSelect(event: any): void {
    const patientId = event.target.value;
    this.selectedPatient = this.patients.find(p => p.id === patientId);
  }

  saveEvaluation(event?: Event): void {
    // Prevenir el comportamiento por defecto del formulario
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
    
    // ALERTA INMEDIATA PARA CONFIRMAR QUE SE EJECUTA
    alert('üöÄ ¬°BOT√ìN FUNCIONANDO! - Guardando en tabla EvaluacionesSensoriales');
    console.log('üöÄ Iniciando saveEvaluation()...');
    console.log('üìä Estado actual completo:', {
      selectedPatient: this.selectedPatient,
      answeredQuestions: this.answeredQuestions,
      totalQuestions: this.totalQuestions,
      patients: this.patients,
      patientIdFromRoute: this.patientIdFromRoute
    });

    // Verificar estado del paciente con m√°s detalle
    if (!this.selectedPatient) {
      console.warn('‚ö†Ô∏è No hay paciente seleccionado, intentando recuperar...');
      
      // Intentar recuperar paciente de la lista si hay uno disponible
      if (this.patients && this.patients.length > 0) {
        console.log('üîÑ Intentando usar el primer paciente disponible...');
        this.selectedPatient = this.patients[0];
        console.log('‚úÖ Paciente recuperado:', this.selectedPatient);
      } else if (this.patientIdFromRoute) {
        console.log('üîÑ Intentando usar ID de ruta:', this.patientIdFromRoute);
        // Aqu√≠ podr√≠as hacer una llamada al servicio para obtener el paciente
      } else {
        alert('‚ö†Ô∏è No hay paciente seleccionado. Por favor, selecciona un paciente antes de guardar.');
      }
    }

    if (this.answeredQuestions === 0) {
      console.error('‚ùå No hay preguntas respondidas');
      alert('Por favor, responde al menos una pregunta antes de guardar.');
      return;
    }

    // Recopilar todas las respuestas
    console.log('üìù Recopilando respuestas...');
    const responses = this.collectResponses();
    console.log('üìã Respuestas recopiladas:', responses);
    
    const progreso = this.totalQuestions > 0 ? Math.round((this.answeredQuestions / this.totalQuestions) * 100) : 0;
    
    // Determinar el estado de la evaluaci√≥n
    const estado = progreso === 100 ? 'Completada' : 'En Progreso';
    
    const evaluacionData: EvaluacionSensorial = {
      idPaciente: parseInt(this.selectedPatient.idPaciente || this.selectedPatient.id),
      progreso: progreso,
      respuestas: responses,
      evaluadorNombre: this.isEditMode && this.currentEvaluacion ? this.currentEvaluacion.evaluadorNombre : 'Dr. Evaluador',
      evaluadorCorreo: this.isEditMode && this.currentEvaluacion ? this.currentEvaluacion.evaluadorCorreo : 'evaluador@test.com',
      observaciones: this.isEditMode && this.currentEvaluacion ? 
        `${this.currentEvaluacion.observaciones || ''} - Actualizado el ${new Date().toLocaleString()}` : 
        `Evaluaci√≥n guardada el ${new Date().toLocaleString()}`,
      estado: estado
    };

    // Si estamos en modo edici√≥n, agregar el ID de la evaluaci√≥n
    if (this.isEditMode && this.currentEvaluacion) {
      evaluacionData.idEvaluacion = this.currentEvaluacion.idEvaluacion;
    }

    console.log('üíæ Datos de evaluaci√≥n preparados:', evaluacionData);
    console.log(`üìù Modo: ${this.isEditMode ? 'ACTUALIZAR' : 'CREAR'} evaluaci√≥n`);

    // Guardar en base de datos
    console.log('üîÑ Enviando a base de datos...');
    
    this.evaluacionService.guardarEvaluacion(evaluacionData).subscribe({
      next: (response) => {
        console.log('‚úÖ Evaluaci√≥n guardada exitosamente:', response);
        const accion = this.isEditMode ? 'actualizada' : 'guardada';
        alert(`‚úÖ Evaluaci√≥n ${accion} exitosamente en la base de datos para ${this.selectedPatient.nombre}\nProgreso: ${progreso}%\nEstado: ${estado}`);
        
        // Actualizar el estado local si estamos editando
        if (this.isEditMode && response.evaluacion) {
          this.currentEvaluacion = response.evaluacion;
        }
        
        // Tambi√©n mantener copia en localStorage como respaldo
        this.saveEvaluationToStorage({
          pacienteId: this.selectedPatient.id,
          pacienteNombre: this.selectedPatient.nombre,
          fechaEvaluacion: new Date().toISOString(),
          preguntasRespondidas: this.answeredQuestions,
          porcentajeCompletado: progreso,
          respuestas: responses,
          seccionesCompletadas: this.sectionProgress.filter(s => s.completed).length,
          estado: estado,
          modoEdicion: this.isEditMode
        });
      },
      error: (error) => {
        console.error('‚ùå Error al guardar evaluaci√≥n:', error);
        const accion = this.isEditMode ? 'actualizar' : 'guardar';
        alert(`‚ùå Error al ${accion} la evaluaci√≥n en la base de datos.\n\nDetalles: ${error.message}\n\nLa evaluaci√≥n se guardar√° localmente como respaldo.`);
        
        // En caso de error, guardar solo localmente
        this.saveEvaluationToStorage({
          pacienteId: this.selectedPatient.id,
          pacienteNombre: this.selectedPatient.nombre,
          fechaEvaluacion: new Date().toISOString(),
          preguntasRespondidas: this.answeredQuestions,
          porcentajeCompletado: progreso,
          respuestas: responses,
          seccionesCompletadas: this.sectionProgress.filter(s => s.completed).length,
          estado: estado,
          guardadoLocal: true,
          modoEdicion: this.isEditMode
        });
      }
    });
  }

  private collectResponses(): any[] {
    console.log('ÔøΩ Recopilando respuestas...');
    
    const responses: any[] = [];
    const checkedInputs = document.querySelectorAll('input[type="radio"]:checked');
    
    console.log(`ÔøΩ Radio buttons seleccionados encontrados: ${checkedInputs.length}`);
    
    checkedInputs.forEach((input: any, index) => {
      const questionElement = input.closest('.question-card, .question-item');
      const questionText = questionElement?.querySelector('.question-text, .pregunta-titulo')?.textContent || `Pregunta ${index + 1}`;
      
      responses.push({
        id: index + 1,
        name: input.name,
        pregunta: questionText.trim(),
        respuesta: input.value,
        puntaje: this.getScoreFromValue(input.value)
      });
      
      console.log(`üìù Respuesta ${index + 1}: ${input.name} = ${input.value}`);
    });
    
    console.log(`ÔøΩ Total de respuestas recopiladas: ${responses.length}`);
    return responses;
  }

  // M√©todo auxiliar para obtener puntaje
  private getScoreFromValue(value: string): number {
    switch(value) {
      case 'nunca': return 1;
      case 'casi-nunca': return 2;
      case 'a-veces': return 3;
      case 'frecuentemente': return 4;
      case 'siempre': return 5;
      default: return 3;
    }
  }

  private saveEvaluationToStorage(evaluationData: any): void {
    const existingEvaluations = JSON.parse(localStorage.getItem('evaluaciones') || '[]');
    
    // Verificar si ya existe una evaluaci√≥n para este paciente
    const existingIndex = existingEvaluations.findIndex((evaluation: any) => evaluation.pacienteId === evaluationData.pacienteId);
    
    if (existingIndex >= 0) {
      // Actualizar evaluaci√≥n existente
      existingEvaluations[existingIndex] = evaluationData;
    } else {
      // Agregar nueva evaluaci√≥n
      existingEvaluations.push(evaluationData);
    }
    
    localStorage.setItem('evaluaciones', JSON.stringify(existingEvaluations));
  }

  private setupProgressTracking(): void {
    // Configurar despu√©s de un peque√±o delay para asegurar que el DOM est√© cargado
    setTimeout(() => {
      this.updateProgress();
      this.attachRadioListeners();
    }, 100);
  }

  private attachRadioListeners(): void {
    // Obtener todos los radio buttons del formulario
    const radioButtons = document.querySelectorAll('input[type="radio"]');
    
    radioButtons.forEach(radio => {
      radio.addEventListener('change', () => {
        this.updateProgress();
      });
    });
  }

  private updateProgress(): void {
    console.log('üîÑ Actualizando progreso...');
    
    // Contar todas las preguntas con respuestas seleccionadas
    const allRadioGroups = document.querySelectorAll('input[type="radio"]:checked');
    this.answeredQuestions = allRadioGroups.length;
    
    console.log(`üìù Preguntas respondidas encontradas: ${this.answeredQuestions}`);
    
    // Calcular porcentaje
    this.progressPercentage = Math.round((this.answeredQuestions / this.totalQuestions) * 100);
    
    // Actualizar progreso circular
    this.updateCircularProgress();

    // Actualizar progreso por secciones
    this.updateSectionProgress();

    // Actualizar el DOM del progreso principal
    this.updateProgressUI();
    
    console.log(`üìä Progreso actualizado: ${this.answeredQuestions}/${this.totalQuestions} = ${this.progressPercentage}%`);
  }

  private updateCircularProgress(): void {
    const progress = this.progressPercentage / 100;
    this.strokeDashoffset = this.circumference - progress * this.circumference;
  }

  private updateSectionProgress(): void {
    this.sectionProgress.forEach((section, index) => {
      const startQuestion = (index * 10) + 1;
      const endQuestion = startQuestion + 9;
      const answered = this.getSectionAnsweredQuestions(startQuestion, endQuestion);
      
      section.answered = answered;
      section.completed = answered === section.total;
    });
  }

  private updateProgressUI(): void {
    // Actualizar el texto del progreso
    const progressText = document.querySelector('.progress-text');
    if (progressText) {
      progressText.textContent = `${this.answeredQuestions}/${this.totalQuestions} preguntas completadas`;
    }

    // Actualizar la barra de progreso
    const progressFill = document.querySelector('.progress-fill') as HTMLElement;
    if (progressFill) {
      progressFill.style.width = `${this.progressPercentage}%`;
    }

    // Actualizar indicadores de secci√≥n
    this.updateSectionIndicators();
  }

  private updateSectionIndicators(): void {
    const sections = [
      { name: 'vision', start: 1, end: 10 },
      { name: 'auditory', start: 11, end: 20 },
      { name: 'tactile', start: 21, end: 30 },
      { name: 'taste-smell', start: 31, end: 40 },
      { name: 'body-awareness', start: 41, end: 50 },
      { name: 'balance-movement', start: 51, end: 60 },
      { name: 'planning-ideas', start: 61, end: 70 },
      { name: 'social-participation', start: 71, end: 80 }
    ];

    sections.forEach(section => {
      const sectionElement = document.querySelector(`.section-indicator.${section.name}`);
      if (sectionElement) {
        const sectionQuestions = this.getSectionAnsweredQuestions(section.start, section.end);
        const totalSectionQuestions = section.end - section.start + 1;
        
        if (sectionQuestions === totalSectionQuestions) {
          sectionElement.classList.add('completed');
        } else {
          sectionElement.classList.remove('completed');
        }
      }
    });
  }

  private getSectionAnsweredQuestions(startQuestion: number, endQuestion: number): number {
    let answered = 0;
    for (let i = startQuestion; i <= endQuestion; i++) {
      const radioButtons = document.querySelectorAll(`input[name="pregunta${i}"]`);
      const isAnswered = Array.from(radioButtons).some((radio: any) => radio.checked);
      
      if (isAnswered) {
        answered++;
      }
    }
    return answered;
  }

  // M√©todo para verificar si hay respuestas (usado en el HTML)
  hasAnswers(): boolean {
    // Verificar si hay radio buttons seleccionados
    const checkedInputs = document.querySelectorAll('input[type="radio"]:checked');
    const hasAnswers = checkedInputs.length > 0;
    
    console.log(`üîç hasAnswers() verificando... ${checkedInputs.length} respuestas encontradas`);
    console.log(`üìä hasAnswers(): ${hasAnswers} (answeredQuestions: ${this.answeredQuestions})`);
    
    return hasAnswers;
  }

  // M√©todo para obtener el progreso actual (usado en el HTML)  
  get currentProgress(): number {
    const progress = this.totalQuestions > 0 ? Math.round((this.answeredQuestions / this.totalQuestions) * 100) : 0;
    console.log(`üìä currentProgress: ${progress}% (${this.answeredQuestions}/${this.totalQuestions})`);
    return progress;
  }

  // M√©todo de debug simple para verificar que el bot√≥n funciona
  // M√©todo de debug (opcional, se puede eliminar en producci√≥n)
  testButton(): void {
    console.log('üß™ Test button - Funcionalidad de debug');
    alert('Funcionalidad de debug activada. Ver consola para detalles.');
  }

  // M√©todo para ir al inicio del componente
  scrollToTop(): void {
    // Hacer scroll suave hacia el inicio del componente
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  }
}
